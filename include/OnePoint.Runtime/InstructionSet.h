//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/chinthan/Framework/Logger/ConvertCode/OnePoint/Runtime/VirtualMachine/InstructionSet.java
//
//  Created by chinthan on 12/2/13.
//



//typedef enum {
//  InstructionSet_aaload = 0,
//  InstructionSet_aastore = 1,
//  InstructionSet_aconst_null = 2,
//  InstructionSet_aload = 3,
//  InstructionSet_aload_0 = 4,
//  InstructionSet_aload_1 = 5,
//  InstructionSet_aload_2 = 6,
//  InstructionSet_aload_3 = 7,
//  InstructionSet_anewarray = 8,
//  InstructionSet_areturn = 9,
//  InstructionSet_arraylength = 10,
//  InstructionSet_astore = 11,
//  InstructionSet_astore_0 = 12,
//  InstructionSet_astore_1 = 13,
//  InstructionSet_astore_2 = 14,
//  InstructionSet_astore_3 = 15,
//  InstructionSet_athrow = 16,
//  InstructionSet_baload = 17,
//  InstructionSet_bastore = 18,
//  InstructionSet_bipush = 19,
//  InstructionSet_caload = 20,
//  InstructionSet_castore = 21,
//  InstructionSet_checkcast = 22,
//  InstructionSet_dadd = 23,
//  InstructionSet_daload = 24,
//  InstructionSet_dastore = 25,
//  InstructionSet_dcmpg = 26,
//  InstructionSet_dcmpl = 27,
//  InstructionSet_dconst_0 = 28,
//  InstructionSet_dconst_1 = 29,
//  InstructionSet_ddiv = 30,
//  InstructionSet_dload = 31,
//  InstructionSet_dload_0 = 32,
//  InstructionSet_dload_1 = 33,
//  InstructionSet_dload_2 = 34,
//  InstructionSet_dload_3 = 35,
//  InstructionSet_dmul = 36,
//  InstructionSet_dneg = 37,
//  InstructionSet_drem = 38,
//  InstructionSet_dreturn = 39,
//  InstructionSet_dstore = 40,
//  InstructionSet_dstore_0 = 41,
//  InstructionSet_dstore_1 = 42,
//  InstructionSet_dstore_2 = 43,
//  InstructionSet_dstore_3 = 44,
//  InstructionSet_dsub = 45,
//  InstructionSet_dup = 46,
//  InstructionSet_dup_x1 = 47,
//  InstructionSet_dup_x2 = 48,
//  InstructionSet_dup2 = 49,
//  InstructionSet_dup2_x1 = 50,
//  InstructionSet_dup2_x2 = 51,
//  InstructionSet_fadd = 52,
//  InstructionSet_faload = 53,
//  InstructionSet_fastore = 54,
//  InstructionSet_fcmpg = 55,
//  InstructionSet_fcmpl = 56,
//  InstructionSet_fconst_0 = 57,
//  InstructionSet_fconst_1 = 58,
//  InstructionSet_fconst_2 = 59,
//  InstructionSet_fdiv = 60,
//  InstructionSet_fload = 61,
//  InstructionSet_fload_0 = 62,
//  InstructionSet_fload_1 = 63,
//  InstructionSet_fload_2 = 64,
//  InstructionSet_fload_3 = 65,
//  InstructionSet_fmul = 66,
//  InstructionSet_fneg = 67,
//  InstructionSet_frem = 68,
//  InstructionSet_freturn = 69,
//  InstructionSet_fstore = 70,
//  InstructionSet_fstore_0 = 71,
//  InstructionSet_fstore_1 = 72,
//  InstructionSet_fstore_2 = 73,
//  InstructionSet_fstore_3 = 74,
//  InstructionSet_fsub = 75,
//  InstructionSet_getfield = 76,
//  InstructionSet_getstatic = 77,
//  InstructionSet_Goto = 78,
//  InstructionSet_goto_w = 79,
//  InstructionSet_i2l = 80,
//  InstructionSet_i2f = 81,
//  InstructionSet_i2d = 82,
//  InstructionSet_l2i = 83,
//  InstructionSet_l2f = 84,
//  InstructionSet_l2d = 85,
//  InstructionSet_f2i = 86,
//  InstructionSet_f2l = 87,
//  InstructionSet_f2d = 88,
//  InstructionSet_d2i = 89,
//  InstructionSet_d2l = 90,
//  InstructionSet_d2f = 91,
//  InstructionSet_i2b = 92,
//  InstructionSet_i2c = 93,
//  InstructionSet_i2s = 94,
//  InstructionSet_iadd = 95,
//  InstructionSet_iaload = 96,
//  InstructionSet_iand = 97,
//  InstructionSet_iastore = 98,
//  InstructionSet_iconst_m1 = 99,
//  InstructionSet_iconst_0 = 100,
//  InstructionSet_iconst_1 = 101,
//  InstructionSet_iconst_2 = 102,
//  InstructionSet_iconst_3 = 103,
//  InstructionSet_iconst_4 = 104,
//  InstructionSet_iconst_5 = 105,
//  InstructionSet_idiv = 106,
//  InstructionSet_if_acmpeq = 107,
//  InstructionSet_if_acmpne = 108,
//  InstructionSet_if_icmpeq = 109,
//  InstructionSet_if_icmpne = 110,
//  InstructionSet_if_icmplt = 111,
//  InstructionSet_if_icmpge = 112,
//  InstructionSet_if_icmpgt = 113,
//  InstructionSet_if_icmple = 114,
//  InstructionSet_ifeq = 115,
//  InstructionSet_ifne = 116,
//  InstructionSet_iflt = 117,
//  InstructionSet_ifge = 118,
//  InstructionSet_ifgt = 119,
//  InstructionSet_ifle = 120,
//  InstructionSet_ifnonnull = 121,
//  InstructionSet_ifnull = 122,
//  InstructionSet_iinc = 123,
//  InstructionSet_iload = 124,
//  InstructionSet_iload_0 = 125,
//  InstructionSet_iload_1 = 126,
//  InstructionSet_iload_2 = 127,
//  InstructionSet_iload_3 = 128,
//  InstructionSet_imul = 129,
//  InstructionSet_ineg = 130,
//  InstructionSet_instanceoff = 131,
//  InstructionSet_invokedynamic = 132,
//  InstructionSet_invokeinterface = 133,
//  InstructionSet_invokespecial = 134,
//  InstructionSet_invokestatic = 135,
//  InstructionSet_invokevirtual = 136,
//  InstructionSet_ior = 137,
//  InstructionSet_irem = 138,
//  InstructionSet_ireturn = 139,
//  InstructionSet_ishl = 140,
//  InstructionSet_ishr = 141,
//  InstructionSet_istore = 142,
//  InstructionSet_istore_0 = 143,
//  InstructionSet_istore_1 = 144,
//  InstructionSet_istore_2 = 145,
//  InstructionSet_istore_3 = 146,
//  InstructionSet_isub = 147,
//  InstructionSet_iushr = 148,
//  InstructionSet_ixor = 149,
//  InstructionSet_jsr = 150,
//  InstructionSet_jsr_w = 151,
//  InstructionSet_ladd = 152,
//  InstructionSet_laload = 153,
//  InstructionSet_land = 154,
//  InstructionSet_lastore = 155,
//  InstructionSet_lcmp = 156,
//  InstructionSet_lconst_0 = 157,
//  InstructionSet_lconst_1 = 158,
//  InstructionSet_ldc = 159,
//  InstructionSet_ldc_w = 160,
//  InstructionSet_ldc2_w = 161,
//  InstructionSet_ldiv = 162,
//  InstructionSet_lload = 163,
//  InstructionSet_lload_0 = 164,
//  InstructionSet_lload_1 = 165,
//  InstructionSet_lload_2 = 166,
//  InstructionSet_lload_3 = 167,
//  InstructionSet_lmul = 168,
//  InstructionSet_lneg = 169,
//  InstructionSet_lookupswitch = 170,
//  InstructionSet_lor = 171,
//  InstructionSet_lrem = 172,
//  InstructionSet_lreturn = 173,
//  InstructionSet_lshl = 174,
//  InstructionSet_lshr = 175,
//  InstructionSet_lstore = 176,
//  InstructionSet_lstore_0 = 177,
//  InstructionSet_lstore_1 = 178,
//  InstructionSet_lstore_2 = 179,
//  InstructionSet_lstore_3 = 180,
//  InstructionSet_lsub = 181,
//  InstructionSet_lushr = 182,
//  InstructionSet_lxor = 183,
//  InstructionSet_monitorenter = 184,
//  InstructionSet_monitorexit = 185,
//  InstructionSet_multianewarray = 186,
//  InstructionSet_New = 187,
//  InstructionSet_newarray = 188,
//  InstructionSet_nop = 189,
//  InstructionSet_pop = 190,
//  InstructionSet_pop2 = 191,
//  InstructionSet_putfield = 192,
//  InstructionSet_putstatic = 193,
//  InstructionSet_ret = 194,
//  InstructionSet_Return = 195,
//  InstructionSet_saload = 196,
//  InstructionSet_sastore = 197,
//  InstructionSet_sipush = 198,
//  InstructionSet_swap = 199,
//  InstructionSet_tableswitch = 200,
//  InstructionSet_wide = 201,
//  InstructionSet_breakpoint = 202,
//  InstructionSet_impdep1 = 203,
//  InstructionSet_impdep2 = 204,
//  InstructionSet_label = 205,
//} InstructionSet;

typedef enum {
    /// <summary>
    /// The aaload.
    /// </summary>
    InstructionSet_aaload = 0x32, // arrayref, index ? value	load onto the stack a reference from an array
    /// <summary>
    /// The aastore.
    /// </summary>
    InstructionSet_aastore = 0x53, // arrayref, index, value ?	store into a reference in an array
    /// <summary>
    /// The aconst_null.
    /// </summary>
    InstructionSet_aconst_null = 0x01, // ? null	push a null reference onto the stack
    /// <summary>
    /// The aload.
    /// </summary>
    InstructionSet_aload = 0x19, // 1: index	? objectref	load a reference onto the stack from a local variable #index
    /// <summary>
    /// The aload_0.
    /// </summary>
    InstructionSet_aload_0 = 0x2a, // ? objectref	load a reference onto the stack from local variable 0
    /// <summary>
    /// The aload_1.
    /// </summary>
    InstructionSet_aload_1 = 0x2b, // ? objectref	load a reference onto the stack from local variable 1
    /// <summary>
    /// The aload_2.
    /// </summary>
    InstructionSet_aload_2 = 0x2c, // ? objectref	load a reference onto the stack from local variable 2
    /// <summary>
    /// The aload_3.
    /// </summary>
    InstructionSet_aload_3 = 0x2d, // ? objectref	load a reference onto the stack from local variable 3
    /// <summary>
    /// The anewarray.
    /// </summary>
    InstructionSet_anewarray = 0xbd,
    
    // 2: indexbyte1, indexbyte2	count ? arrayref	create a new array of references of length count and component type identified by the class reference index (indexbyte1 << 8 + indexbyte2) in the constant pool
    /// <summary>
    /// The areturn.
    /// </summary>
    InstructionSet_areturn = 0xb0, // objectref ? [empty]	return a reference from a method
    /// <summary>
    /// The arraylength.
    /// </summary>
    InstructionSet_arraylength = 0xbe, // arrayref ? length	get the length of an array
    /// <summary>
    /// The astore.
    /// </summary>
    InstructionSet_astore = 0x3a, // 1: index	objectref ?	store a reference into a local variable #index
    /// <summary>
    /// The astore_0.
    /// </summary>
    InstructionSet_astore_0 = 0x4b, // objectref ?	store a reference into local variable 0
    /// <summary>
    /// The astore_1.
    /// </summary>
    InstructionSet_astore_1 = 0x4c, // objectref ?	store a reference into local variable 1
    /// <summary>
    /// The astore_2.
    /// </summary>
    InstructionSet_astore_2 = 0x4d, // objectref ?	store a reference into local variable 2
    /// <summary>
    /// The astore_3.
    /// </summary>
    InstructionSet_astore_3 = 0x4e, // objectref ?	store a reference into local variable 3
    /// <summary>
    /// The athrow.
    /// </summary>
    InstructionSet_athrow = 0xbf,
    
    // objectref ? [empty], objectref	throws an error or exception (notice that the rest of the stack is cleared, leaving only a reference to the Throwable)
    /// <summary>
    /// The baload.
    /// </summary>
    InstructionSet_baload = 0x33, // arrayref, index ? value	load a byte or Boolean value from an array
    /// <summary>
    /// The bastore.
    /// </summary>
    InstructionSet_bastore = 0x54, // arrayref, index, value ?	store a byte or Boolean value into an array
    /// <summary>
    /// The bipush.
    /// </summary>
    InstructionSet_bipush = 0x10, // 1: byte	? value	push a byte onto the stack as an integer value
    /// <summary>
    /// The caload.
    /// </summary>
    InstructionSet_caload = 0x34, // arrayref, index ? value	load a char from an array
    /// <summary>
    /// The castore.
    /// </summary>
    InstructionSet_castore = 0x55, // arrayref, index, value ?	store a char into an array
    /// <summary>
    /// The checkcast.
    /// </summary>
    InstructionSet_checkcast = 0xc0,
    
    // 2: indexbyte1, indexbyte2	objectref ? objectref	checks whether an objectref is of a certain type, the class reference of which is in the constant pool at index (indexbyte1 << 8 + indexbyte2)
    /// <summary>
    /// The dadd.
    /// </summary>
    InstructionSet_dadd = 0x63, // value1, value2 ? result	add two doubles
    /// <summary>
    /// The daload.
    /// </summary>
    InstructionSet_daload = 0x31, // arrayref, index ? value	load a double from an array
    /// <summary>
    /// The dastore.
    /// </summary>
    InstructionSet_dastore = 0x52, // arrayref, index, value ?	store a double into an array
    /// <summary>
    /// The dcmpg.
    /// </summary>
    InstructionSet_dcmpg = 0x98, // value1, value2 ? result	compare two doubles
    /// <summary>
    /// The dcmpl.
    /// </summary>
    InstructionSet_dcmpl = 0x97, // value1, value2 ? result	compare two doubles
    /// <summary>
    /// The dconst_0.
    /// </summary>
    InstructionSet_dconst_0 = 0x0e, // ? 0.0	push the constant 0.0 onto the stack
    /// <summary>
    /// The dconst_1.
    /// </summary>
    InstructionSet_dconst_1 = 0x0f, // ? 1.0	push the constant 1.0 onto the stack
    /// <summary>
    /// The ddiv.
    /// </summary>
    InstructionSet_ddiv = 0x6f, // value1, value2 ? result	divide two doubles
    /// <summary>
    /// The dload.
    /// </summary>
    InstructionSet_dload = 0x18, // 1: index	? value	load a double value from a local variable #index
    /// <summary>
    /// The dload_0.
    /// </summary>
    InstructionSet_dload_0 = 0x26, // ? value	load a double from local variable 0
    /// <summary>
    /// The dload_1.
    /// </summary>
    InstructionSet_dload_1 = 0x27, // ? value	load a double from local variable 1
    /// <summary>
    /// The dload_2.
    /// </summary>
    InstructionSet_dload_2 = 0x28, // ? value	load a double from local variable 2
    /// <summary>
    /// The dload_3.
    /// </summary>
    InstructionSet_dload_3 = 0x29, // ? value	load a double from local variable 3
    /// <summary>
    /// The dmul.
    /// </summary>
    InstructionSet_dmul = 0x6b, // value1, value2 ? result	multiply two doubles
    /// <summary>
    /// The dneg.
    /// </summary>
    InstructionSet_dneg = 0x77, // value ? result	negate a double
    /// <summary>
    /// The drem.
    /// </summary>
    InstructionSet_drem = 0x73, // value1, value2 ? result	get the remainder from a division between two doubles
    /// <summary>
    /// The dreturn.
    /// </summary>
    InstructionSet_dreturn = 0xaf, // value ? [empty]	return a double from a method
    /// <summary>
    /// The dstore.
    /// </summary>
    InstructionSet_dstore = 0x39, // 1: index	value ?	store a double value into a local variable #index
    /// <summary>
    /// The dstore_0.
    /// </summary>
    InstructionSet_dstore_0 = 0x47, // value ?	store a double into local variable 0
    /// <summary>
    /// The dstore_1.
    /// </summary>
    InstructionSet_dstore_1 = 0x48, // value ?	store a double into local variable 1
    /// <summary>
    /// The dstore_2.
    /// </summary>
    InstructionSet_dstore_2 = 0x49, // value ?	store a double into local variable 2
    /// <summary>
    /// The dstore_3.
    /// </summary>
    InstructionSet_dstore_3 = 0x4a, // value ?	store a double into local variable 3
    /// <summary>
    /// The dsub.
    /// </summary>
    InstructionSet_dsub = 0x67, // value1, value2 ? result	subtract a double from another
    /// <summary>
    /// The dup.
    /// </summary>
    InstructionSet_dup = 0x59, // value ? value, value	duplicate the value on top of the stack
    /// <summary>
    /// The dup_x 1.
    /// </summary>
    InstructionSet_dup_x1 = 0x5a,
    
    // value2, value1 ? value1, value2, value1	insert a copy of the top value into the stack two values from the top. value1 and value2 must not be of the type double or long.
    /// <summary>
    /// The dup_x 2.
    /// </summary>
    InstructionSet_dup_x2 = 0x5b,
    
    // value3, value2, value1 ? value1, value3, value2, value1	insert a copy of the top value into the stack two (if value2 is double or long it takes up the entry of value3, too) or three values (if value2 is neither double nor long) from the top
    /// <summary>
    /// The dup 2.
    /// </summary>
    InstructionSet_dup2 = 0x5c,
    
    // {value2, value1} ? {value2, value1}, {value2, value1}	duplicate top two stack words (two values, if value1 is not double nor long; a single value, if value1 is double or long)
    /// <summary>
    /// The dup 2_x 1.
    /// </summary>
    InstructionSet_dup2_x1 = 0x5d,
    
    // value3, {value2, value1} ? {value2, value1}, value3, {value2, value1}	duplicate two words and insert beneath third word (see explanation above)
    /// <summary>
    /// The dup 2_x 2.
    /// </summary>
    InstructionSet_dup2_x2 = 0x5e,
    
    // {value4, value3}, {value2, value1} ? {value2, value1}, {value4, value3}, {value2, value1}	duplicate two words and insert beneath fourth word
    /// <summary>
    /// The fadd.
    /// </summary>
    InstructionSet_fadd = 0x62, // value1, value2 ? result	add two floats
    /// <summary>
    /// The faload.
    /// </summary>
    InstructionSet_faload = 0x30, // arrayref, index ? value	load a float from an array
    /// <summary>
    /// The fastore.
    /// </summary>
    InstructionSet_fastore = 0x51, // arrayref, index, value ?	store a float in an array
    /// <summary>
    /// The fcmpg.
    /// </summary>
    InstructionSet_fcmpg = 0x96, // value1, value2 ? result	compare two floats
    /// <summary>
    /// The fcmpl.
    /// </summary>
    InstructionSet_fcmpl = 0x95, // value1, value2 ? result	compare two floats
    /// <summary>
    /// The fconst_0.
    /// </summary>
    InstructionSet_fconst_0 = 0x0b, // ? 0.0f	push 0.0f on the stack
    /// <summary>
    /// The fconst_1.
    /// </summary>
    InstructionSet_fconst_1 = 0x0c, // ? 1.0f	push 1.0f on the stack
    /// <summary>
    /// The fconst_2.
    /// </summary>
    InstructionSet_fconst_2 = 0x0d, // ? 2.0f	push 2.0f on the stack
    /// <summary>
    /// The fdiv.
    /// </summary>
    InstructionSet_fdiv = 0x6e, // value1, value2 ? result	divide two floats
    /// <summary>
    /// The fload.
    /// </summary>
    InstructionSet_fload = 0x17, // 1: index	? value	load a float value from a local variable #index
    /// <summary>
    /// The fload_0.
    /// </summary>
    InstructionSet_fload_0 = 0x22, // ? value	load a float value from local variable 0
    /// <summary>
    /// The fload_1.
    /// </summary>
    InstructionSet_fload_1 = 0x23, // ? value	load a float value from local variable 1
    /// <summary>
    /// The fload_2.
    /// </summary>
    InstructionSet_fload_2 = 0x24, // ? value	load a float value from local variable 2
    /// <summary>
    /// The fload_3.
    /// </summary>
    InstructionSet_fload_3 = 0x25, // ? value	load a float value from local variable 3
    /// <summary>
    /// The fmul.
    /// </summary>
    InstructionSet_fmul = 0x6a, // value1, value2 ? result	multiply two floats
    /// <summary>
    /// The fneg.
    /// </summary>
    InstructionSet_fneg = 0x76, // value ? result	negate a float
    /// <summary>
    /// The frem.
    /// </summary>
    InstructionSet_frem = 0x72, // value1, value2 ? result	get the remainder from a division between two floats
    /// <summary>
    /// The freturn.
    /// </summary>
    InstructionSet_freturn = 0xae, // value ? [empty]	return a float
    /// <summary>
    /// The fstore.
    /// </summary>
    InstructionSet_fstore = 0x38, // 1: index	value ?	store a float value into a local variable #index
    /// <summary>
    /// The fstore_0.
    /// </summary>
    InstructionSet_fstore_0 = 0x43, // value ?	store a float value into local variable 0
    /// <summary>
    /// The fstore_1.
    /// </summary>
    InstructionSet_fstore_1 = 0x44, // value ?	store a float value into local variable 1
    /// <summary>
    /// The fstore_2.
    /// </summary>
    InstructionSet_fstore_2 = 0x45, // value ?	store a float value into local variable 2
    /// <summary>
    /// The fstore_3.
    /// </summary>
    InstructionSet_fstore_3 = 0x46, // value ?	store a float value into local variable 3
    /// <summary>
    /// The fsub.
    /// </summary>
    InstructionSet_fsub = 0x66, // value1, value2 ? result	subtract two floats
    /// <summary>
    /// The getfield.
    /// </summary>
    InstructionSet_getfield = 0xb4,
    
    // 2: index1, index2	objectref ? value	get a field value of an object objectref, where the field is identified by field reference in the constant pool index (index1 << 8 + index2)
    /// <summary>
    /// The getstatic.
    /// </summary>
    InstructionSet_getstatic = 0xb2,
    
    // 2: index1, index2	? value	get a static field value of a class, where the field is identified by field reference in the constant pool index (index1 << 8 + index2)
    /// <summary>
    /// The goto.
    /// </summary>
    InstructionSet_Goto = 0xa7,
    
    // 2: branchbyte1, branchbyte2	[no change]	goes to another instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    /// <summary>
    /// The goto_w.
    /// </summary>
    InstructionSet_goto_w = 0xc8,
    
    // 4: branchbyte1, branchbyte2, branchbyte3, branchbyte4	[no change]	goes to another instruction at branchoffset (signed int constructed from unsigned bytes branchbyte1 << 24 + branchbyte2 << 16 + branchbyte3 << 8 + branchbyte4)
    /// <summary>
    /// The i 2 l.
    /// </summary>
    InstructionSet_i2l = 0x85, // value ? result	convert an int into a long
    /// <summary>
    /// The i 2 f.
    /// </summary>
    InstructionSet_i2f = 0x86, // value ? result	convert an int into a float
    /// <summary>
    /// The i 2 d.
    /// </summary>
    InstructionSet_i2d = 0x87, // value ? result	convert an int into a double
    /// <summary>
    /// The l 2 i.
    /// </summary>
    InstructionSet_l2i = 0x88, // value ? result	convert a long to a int
    /// <summary>
    /// The l 2 f.
    /// </summary>
    InstructionSet_l2f = 0x89, // value ? result	convert a long to a float
    /// <summary>
    /// The l 2 d.
    /// </summary>
    InstructionSet_l2d = 0x8a, // value ? result	convert a long to a double
    /// <summary>
    /// The f 2 i.
    /// </summary>
    InstructionSet_f2i = 0x8b, // value ? result	convert a float to an int
    /// <summary>
    /// The f 2 l.
    /// </summary>
    InstructionSet_f2l = 0x8c, // value ? result	convert a float to a long
    /// <summary>
    /// The f 2 d.
    /// </summary>
    InstructionSet_f2d = 0x8d, // value ? result	convert a float to a double
    /// <summary>
    /// The d 2 i.
    /// </summary>
   InstructionSet_d2i = 0x8e, // value ? result	convert a double to an int
    /// <summary>
    /// The d 2 l.
    /// </summary>
    InstructionSet_d2l = 0x8f, // value ? result	convert a double to a long
    /// <summary>
    /// The d 2 f.
    /// </summary>
    InstructionSet_d2f = 0x90, // value ? result	convert a double to a float
    /// <summary>
    /// The i 2 b.
    /// </summary>
    InstructionSet_i2b = 0x91, // value ? result	convert an int into a byte
    /// <summary>
    /// The i 2 c.
    /// </summary>
    InstructionSet_i2c = 0x92, // value ? result	convert an int into a character
    /// <summary>
    /// The i 2 s.
    /// </summary>
    InstructionSet_i2s = 0x93, // value ? result	convert an int into a short
    /// <summary>
    /// The iadd.
    /// </summary>
    InstructionSet_iadd = 0x60, // value1, value2 ? result	add two ints
    /// <summary>
    /// The iaload.
    /// </summary>
    InstructionSet_iaload = 0x2e, // arrayref, index ? value	load an int from an array
    /// <summary>
    /// The iand.
    /// </summary>
    InstructionSet_iand = 0x7e, // value1, value2 ? result	perform a bitwise and on two integers
    /// <summary>
    /// The iastore.
    /// </summary>
    InstructionSet_iastore = 0x4f, // arrayref, index, value ?	store an int into an array
    /// <summary>
    /// The iconst_m 1.
    /// </summary>
    InstructionSet_iconst_m1 = 0x02, // ? -1	load the int value -1 onto the stack
    /// <summary>
    /// The iconst_0.
    /// </summary>
    InstructionSet_iconst_0 = 0x03, // ? 0	load the int value 0 onto the stack
    /// <summary>
    /// The iconst_1.
    /// </summary>
    InstructionSet_iconst_1 = 0x04, // ? 1	load the int value 1 onto the stack
    /// <summary>
    /// The iconst_2.
    /// </summary>
    InstructionSet_iconst_2 = 0x05, // ? 2	load the int value 2 onto the stack
    /// <summary>
    /// The iconst_3.
    /// </summary>
    InstructionSet_iconst_3 = 0x06, // ? 3	load the int value 3 onto the stack
    /// <summary>
    /// The iconst_4.
    /// </summary>
    InstructionSet_iconst_4 = 0x07, // ? 4	load the int value 4 onto the stack
    /// <summary>
    /// The iconst_5.
    /// </summary>
    InstructionSet_iconst_5 = 0x08, // ? 5	load the int value 5 onto the stack
    /// <summary>
    /// The idiv.
    /// </summary>
    InstructionSet_idiv = 0x6c, // value1, value2 ? result	divide two integers
    /// <summary>
    /// The if_acmpeq.
    /// </summary>
    InstructionSet_if_acmpeq = 0xa5,
    
    // 2: branchbyte1, branchbyte2	value1, value2 ?	if references are equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    /// <summary>
    /// The if_acmpne.
    /// </summary>
    InstructionSet_if_acmpne = 0xa6,
    
    // 2: branchbyte1, branchbyte2	value1, value2 ?	if references are not equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    /// <summary>
    /// The if_icmpeq.
    /// </summary>
    InstructionSet_if_icmpeq = 0x9f,
    
    // 2: branchbyte1, branchbyte2	value1, value2 ?	if ints are equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    /// <summary>
    /// The if_icmpne.
    /// </summary>
    InstructionSet_if_icmpne = 0xa0,
    
    // 2: branchbyte1, branchbyte2	value1, value2 ?	if ints are not equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    /// <summary>
    /// The if_icmplt.
    /// </summary>
    InstructionSet_if_icmplt = 0xa1,
    
    // 2: branchbyte1, branchbyte2	value1, value2 ?	if value1 is less than value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    /// <summary>
    /// The if_icmpge.
    /// </summary>
    InstructionSet_if_icmpge = 0xa2,
    
    // 2: branchbyte1, branchbyte2	value1, value2 ?	if value1 is greater than or equal to value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    /// <summary>
    /// The if_icmpgt.
    /// </summary>
    InstructionSet_if_icmpgt = 0xa3,
    
    // 2: branchbyte1, branchbyte2	value1, value2 ?	if value1 is greater than value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    /// <summary>
    /// The if_icmple.
    /// </summary>
    InstructionSet_if_icmple = 0xa4,
    
    // 2: branchbyte1, branchbyte2	value1, value2 ?	if value1 is less than or equal to value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    /// <summary>
    /// The ifeq.
    /// </summary>
    InstructionSet_ifeq = 0x99,
    
    // 2: branchbyte1, branchbyte2	value ?	if value is 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    /// <summary>
    /// The ifne.
    /// </summary>
    InstructionSet_ifne = 0x9a,
    
    // 2: branchbyte1, branchbyte2	value ?	if value is not 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    /// <summary>
    /// The iflt.
    /// </summary>
    InstructionSet_iflt = 0x9b,
    
    // 2: branchbyte1, branchbyte2	value ?	if value is less than 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    /// <summary>
    /// The ifge.
    /// </summary>
    InstructionSet_ifge = 0x9c,
    
    // 2: branchbyte1, branchbyte2	value ?	if value is greater than or equal to 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    /// <summary>
    /// The ifgt.
    /// </summary>
    InstructionSet_ifgt = 0x9d,
    
    // 2: branchbyte1, branchbyte2	value ?	if value is greater than 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    /// <summary>
    /// The ifle.
    /// </summary>
    InstructionSet_ifle = 0x9e,
    
    // 2: branchbyte1, branchbyte2	value ?	if value is less than or equal to 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    /// <summary>
    /// The ifnonnull.
    /// </summary>
    InstructionSet_ifnonnull = 0xc7,
    
    // 2: branchbyte1, branchbyte2	value ?	if value is not null, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    /// <summary>
    /// The ifnull.
    /// </summary>
    InstructionSet_ifnull = 0xc6,
    
    // 2: branchbyte1, branchbyte2	value ?	if value is null, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    /// <summary>
    /// The iinc.
    /// </summary>
    InstructionSet_iinc = 0x84, // 2: index, const	[No change]	increment local variable #index by signed byte const
    /// <summary>
    /// The iload.
    /// </summary>
    InstructionSet_iload = 0x15, // 1: index	? value	load an int value from a local variable #index
    /// <summary>
    /// The iload_0.
    /// </summary>
    InstructionSet_iload_0 = 0x1a, // ? value	load an int value from local variable 0
    /// <summary>
    /// The iload_1.
    /// </summary>
    InstructionSet_iload_1 = 0x1b, // ? value	load an int value from local variable 1
    /// <summary>
    /// The iload_2.
    /// </summary>
    InstructionSet_iload_2 = 0x1c, // ? value	load an int value from local variable 2
    /// <summary>
    /// The iload_3.
    /// </summary>
    InstructionSet_iload_3 = 0x1d, // ? value	load an int value from local variable 3
    /// <summary>
    /// The imul.
    /// </summary>
    InstructionSet_imul = 0x68, // value1, value2 ? result	multiply two integers
    /// <summary>
    /// The ineg.
    /// </summary>
    InstructionSet_ineg = 0x74, // value ? result	negate int
    /// <summary>
    /// The instanceof.
    /// </summary>
    InstructionSet_instanceof = 0xc1,
    
    // 2: indexbyte1, indexbyte2	objectref ? result	determines if an object objectref is of a given type, identified by class reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    /// <summary>
    /// The invokedynamic.
    /// </summary>
    InstructionSet_invokedynamic = 0xba,
    
    // 4: indexbyte1, indexbyte2, 0, 0	[arg1, [arg2 ...]] ?	invokes a dynamic method identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    /// <summary>
    /// The invokeinterface.
    /// </summary>
    InstructionSet_invokeinterface = 0xb9,
    
    // 4: indexbyte1, indexbyte2, count, 0	objectref, [arg1, arg2, ...] ?	invokes an interface method on object objectref, where the interface method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    /// <summary>
    /// The invokespecial.
    /// </summary>
    InstructionSet_invokespecial = 0xb7,
    
    // 2: indexbyte1, indexbyte2	objectref, [arg1, arg2, ...] ?	invoke instance method on object objectref, where the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    /// <summary>
    /// The invokestatic.
    /// </summary>
    InstructionSet_invokestatic = 0xb8,
    
    // 2: indexbyte1, indexbyte2	[arg1, arg2, ...] ?	invoke a static method, where the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    /// <summary>
    /// The invokevirtual.
    /// </summary>
    InstructionSet_invokevirtual = 0xb6,
    
    // 2: indexbyte1, indexbyte2	objectref, [arg1, arg2, ...] ?	invoke virtual method on object objectref, where the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    /// <summary>
    /// The ior.
    /// </summary>
    InstructionSet_ior = 0x80, // value1, value2 ? result	bitwise int or
    /// <summary>
    /// The irem.
    /// </summary>
    InstructionSet_irem = 0x70, // value1, value2 ? result	logical int remainder
    /// <summary>
    /// The ireturn.
    /// </summary>
    InstructionSet_ireturn = 0xac, // value ? [empty]	return an integer from a method
    /// <summary>
    /// The ishl.
    /// </summary>
    InstructionSet_ishl = 0x78, // value1, value2 ? result	int shift left
    /// <summary>
    /// The ishr.
    /// </summary>
    InstructionSet_ishr = 0x7a, // value1, value2 ? result	int arithmetic shift right
    /// <summary>
    /// The istore.
    /// </summary>
    InstructionSet_istore = 0x36, // 1: index	value ?	store int value into variable #index
    /// <summary>
    /// The istore_0.
    /// </summary>
    InstructionSet_istore_0 = 0x3b, // value ?	store int value into variable 0
    /// <summary>
    /// The istore_1.
    /// </summary>
    InstructionSet_istore_1 = 0x3c, // value ?	store int value into variable 1
    /// <summary>
    /// The istore_2.
    /// </summary>
    InstructionSet_istore_2 = 0x3d, // value ?	store int value into variable 2
    /// <summary>
    /// The istore_3.
    /// </summary>
    InstructionSet_istore_3 = 0x3e, // value ?	store int value into variable 3
    /// <summary>
    /// The isub.
    /// </summary>
    InstructionSet_isub = 0x64, // value1, value2 ? result	int subtract
    /// <summary>
    /// The iushr.
    /// </summary>
    InstructionSet_iushr = 0x7c, // value1, value2 ? result	int logical shift right
    /// <summary>
    /// The ixor.
    /// </summary>
    InstructionSet_ixor = 0x82, // value1, value2 ? result	int xor
    /// <summary>
    /// The jsr.
    /// </summary>
    InstructionSet_jsr = 0xa8,
    
    // 2: branchbyte1, branchbyte2	? address	jump to subroutine at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2) and place the return address on the stack
    /// <summary>
    /// The jsr_w.
    /// </summary>
    InstructionSet_jsr_w = 0xc9,
    
    // 4: branchbyte1, branchbyte2, branchbyte3, branchbyte4	? address	jump to subroutine at branchoffset (signed int constructed from unsigned bytes branchbyte1 << 24 + branchbyte2 << 16 + branchbyte3 << 8 + branchbyte4) and place the return address on the stack
    /// <summary>
    /// The ladd.
    /// </summary>
    InstructionSet_ladd = 0x61, // value1, value2 ? result	add two longs
    /// <summary>
    /// The laload.
    /// </summary>
    InstructionSet_laload = 0x2f, // arrayref, index ? value	load a long from an array
    /// <summary>
    /// The land.
    /// </summary>
    InstructionSet_land = 0x7f, // value1, value2 ? result	bitwise and of two longs
    /// <summary>
    /// The lastore.
    /// </summary>
    InstructionSet_lastore = 0x50, // arrayref, index, value ?	store a long to an array
    /// <summary>
    /// The lcmp.
    /// </summary>
    InstructionSet_lcmp = 0x94, // value1, value2 ? result	compare two longs values
    /// <summary>
    /// The lconst_0.
    /// </summary>
    InstructionSet_lconst_0 = 0x09, // ? 0L	push the long 0 onto the stack
    /// <summary>
    /// The lconst_1.
    /// </summary>
    InstructionSet_lconst_1 = 0x0a, // ? 1L	push the long 1 onto the stack
    /// <summary>
    /// The ldc.
    /// </summary>
    InstructionSet_ldc = 0x12,
    
    // 1: index	? value	push a constant #index from a constant pool (String, int or float) onto the stack
    /// <summary>
    /// The ldc_w.
    /// </summary>
    InstructionSet_ldc_w = 0x13,
    
    // 2: indexbyte1, indexbyte2	? value	push a constant #index from a constant pool (String, int or float) onto the stack (wide index is constructed as indexbyte1 << 8 + indexbyte2)
    /// <summary>
    /// The ldc 2_w.
    /// </summary>
    InstructionSet_ldc2_w = 0x14,
    
    // 2: indexbyte1, indexbyte2	? value	push a constant #index from a constant pool (double or long) onto the stack (wide index is constructed as indexbyte1 << 8 + indexbyte2)
    /// <summary>
    /// The ldiv.
    /// </summary>
    InstructionSet_ldiv = 0x6d, // value1, value2 ? result	divide two longs
    /// <summary>
    /// The lload.
    /// </summary>
    InstructionSet_lload = 0x16, // 1: index	? value	load a long value from a local variable #index
    /// <summary>
    /// The lload_0.
    /// </summary>
    InstructionSet_lload_0 = 0x1e, // ? value	load a long value from a local variable 0
    /// <summary>
    /// The lload_1.
    /// </summary>
    InstructionSet_lload_1 = 0x1f, // ? value	load a long value from a local variable 1
    /// <summary>
    /// The lload_2.
    /// </summary>
    InstructionSet_lload_2 = 0x20, // ? value	load a long value from a local variable 2
    /// <summary>
    /// The lload_3.
    /// </summary>
    InstructionSet_lload_3 = 0x21, // ? value	load a long value from a local variable 3
    /// <summary>
    /// The lmul.
    /// </summary>
    InstructionSet_lmul = 0x69, // value1, value2 ? result	multiply two longs
    /// <summary>
    /// The lneg.
    /// </summary>
    InstructionSet_lneg = 0x75, // value ? result	negate a long
    /// <summary>
    /// The lookupswitch.
    /// </summary>
    InstructionSet_lookupswitch = 0xab,
    
    // 4+: <0-3 bytes padding>, defaultbyte1, defaultbyte2, defaultbyte3, defaultbyte4, npairs1, npairs2, npairs3, npairs4, match-offset pairs...	key ?	a target address is looked up from a table using a key and execution continues from the instruction at that address
    /// <summary>
    /// The lor.
    /// </summary>
    InstructionSet_lor = 0x81, // value1, value2 ? result	bitwise or of two longs
    /// <summary>
    /// The lrem.
    /// </summary>
    InstructionSet_lrem = 0x71, // value1, value2 ? result	remainder of division of two longs
    /// <summary>
    /// The lreturn.
    /// </summary>
    InstructionSet_lreturn = 0xad, // value ? [empty]	return a long value
    /// <summary>
    /// The lshl.
    /// </summary>
    InstructionSet_lshl = 0x79, // value1, value2 ? result	bitwise shift left of a long value1 by value2 positions
    /// <summary>
    /// The lshr.
    /// </summary>
    InstructionSet_lshr = 0x7b, // value1, value2 ? result	bitwise shift right of a long value1 by value2 positions
    /// <summary>
    /// The lstore.
    /// </summary>
    InstructionSet_lstore = 0x37, // 1: index	value ?	store a long value in a local variable #index
    /// <summary>
    /// The lstore_0.
    /// </summary>
    InstructionSet_lstore_0 = 0x3f, // value ?	store a long value in a local variable 0
    /// <summary>
    /// The lstore_1.
    /// </summary>
    InstructionSet_lstore_1 = 0x40, // value ?	store a long value in a local variable 1
    /// <summary>
    /// The lstore_2.
    /// </summary>
    InstructionSet_lstore_2 = 0x41, // value ?	store a long value in a local variable 2
    /// <summary>
    /// The lstore_3.
    /// </summary>
    InstructionSet_lstore_3 = 0x42, // value ?	store a long value in a local variable 3
    /// <summary>
    /// The lsub.
    /// </summary>
    InstructionSet_lsub = 0x65, // value1, value2 ? result	subtract two longs
    /// <summary>
    /// The lushr.
    /// </summary>
    InstructionSet_lushr = 0x7d, // value1, value2 ? result	bitwise shift right of a long value1 by value2 positions, unsigned
    /// <summary>
    /// The lxor.
    /// </summary>
    InstructionSet_lxor = 0x83, // value1, value2 ? result	bitwise exclusive or of two longs
    /// <summary>
    /// The monitorenter.
    /// </summary>
    InstructionSet_monitorenter = 0xc2, // objectref ?	enter monitor for object ("grab the lock" - start of synchronized() section)
    /// <summary>
    /// The monitorexit.
    /// </summary>
    InstructionSet_monitorexit = 0xc3, // objectref ?	exit monitor for object ("release the lock" - end of synchronized() section)
    /// <summary>
    /// The multianewarray.
    /// </summary>
    InstructionSet_multianewarray = 0xc5,
    
    // 3: indexbyte1, indexbyte2, dimensions	count1, [count2,...] ? arrayref	create a new array of dimensions dimensions with elements of type identified by class reference in constant pool index (indexbyte1 << 8 + indexbyte2); the sizes of each dimension is identified by count1, [count2, etc.]
    /// <summary>
    /// The new.
    /// </summary>
    InstructionSet_New = 0xbb,
    
    // 2: indexbyte1, indexbyte2	? objectref	create new object of type identified by class reference in constant pool index (indexbyte1 << 8 + indexbyte2)
    /// <summary>
    /// The newarray.
    /// </summary>
    InstructionSet_newarray = 0xbc,
    
    // 1: atype	count ? arrayref	create new array with count elements of primitive type identified by atype
    /// <summary>
    /// The nop.
    /// </summary>
    InstructionSet_nop = 0x00, // [No change]	perform no operation
    /// <summary>
    /// The pop.
    /// </summary>
    InstructionSet_pop = 0x57, // value ?	discard the top value on the stack
    /// <summary>
    /// The pop 2.
    /// </summary>
    InstructionSet_pop2 = 0x58,
    
    // {value2, value1} ?	discard the top two values on the stack (or one value, if it is a double or long)
    /// <summary>
    /// The putfield.
    /// </summary>
    InstructionSet_putfield = 0xb5,
    
    // 2: indexbyte1, indexbyte2	objectref, value ?	set field to value in an object objectref, where the field is identified by a field reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    /// <summary>
    /// The putstatic.
    /// </summary>
    InstructionSet_putstatic = 0xb3,
    
    // 2: indexbyte1, indexbyte2	value ?	set static field to value in a class, where the field is identified by a field reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    /// <summary>
    /// The ret.
    /// </summary>
    InstructionSet_ret = 0xa9,
    
    // 1: index	[No change]	continue execution from address taken from a local variable #index (the asymmetry with jsr is intentional)
    /// <summary>
    /// The return.
    /// </summary>
    InstructionSet_Return = 0xb1, // ? [empty]	return void from method
    /// <summary>
    /// The saload.
    /// </summary>
    InstructionSet_saload = 0x35, // arrayref, index ? value	load short from array
    /// <summary>
    /// The sastore.
    /// </summary>
    InstructionSet_sastore = 0x56, // arrayref, index, value ?	store short to array
    /// <summary>
    /// The sipush.
    /// </summary>
    InstructionSet_sipush = 0x11, // 2: byte1, byte2	? value	push a short onto the stack
    /// <summary>
    /// The swap.
    /// </summary>
    InstructionSet_swap = 0x5f,
    
    // value2, value1 ? value1, value2	swaps two top words on the stack (note that value1 and value2 must not be double or long)
    /// <summary>
    /// The tableswitch.
    /// </summary>
    InstructionSet_tableswitch = 0xaa,
    
    // 4+: [0-3 bytes padding], defaultbyte1, defaultbyte2, defaultbyte3, defaultbyte4, lowbyte1, lowbyte2, lowbyte3, lowbyte4, highbyte1, highbyte2, highbyte3, highbyte4, jump offsets...	index ?	continue execution from an address in the table at offset index
    /// <summary>
    /// The wide.
    /// </summary>
    InstructionSet_wide = 0xc4,
    
    // 3/5: opcode, indexbyte1, indexbyte2 or iinc, indexbyte1, indexbyte2, countbyte1, countbyte2	[same as for corresponding instructions]	execute opcode, where opcode is either iload, fload, aload, lload, dload, istore, fstore, astore, lstore, dstore, or ret, but assume the index is 16 bit; or execute iinc, where the index is 16 bits and the constant to increment by is a signed 16 bit short
    /// <summary>
    /// The breakpoint.
    /// </summary>
    InstructionSet_breakpoint = 0xca, // reserved for breakpoints in Java debuggers; should not appear in any class file
    /// <summary>
    /// The impdep 1.
    /// </summary>
    InstructionSet_impdep1 = 0xfe,
    
    // reserved for implementation-dependent operations within debuggers; should not appear in any class file
    /// <summary>
    /// The impdep 2.
    /// </summary>
    InstructionSet_impdep2 = 0xff,
    
    // reserved for implementation-dependent operations within debuggers; should not appear in any class file
    // (no name )	cb-fd			these values are currently unassigned for opcodes and are reserved for future use
    
    /// <summary>
    /// Dummy Label instructions for the compiler
    /// </summary>
    InstructionSet_label = 0xff01,
    
    InstructionSet_get = 0xff02,
    
    InstructionSet_set = 0xff03,
    
    InstructionSet_dispose = 0xff04,
    
    InstructionSet_call = 0xff05,
    
    InstructionSet_add = 0xff06,
    
    InstructionSet_subtract = 0xff07,
    
    InstructionSet_divide = 0xff08,
    
    InstructionSet_multiply = 0xff09,
    
    InstructionSet_modulus = 0xff10,
    
    InstructionSet_declare = 0xff11
    } InstructionSet;

//@interface InstructionSetEnum : NSObject {
//}
//+ (InstructionSetEnum *)aaload;
//+ (InstructionSetEnum *)aastore;
//+ (InstructionSetEnum *)aconst_null;
//+ (InstructionSetEnum *)aload;
//+ (InstructionSetEnum *)aload_0;
//+ (InstructionSetEnum *)aload_1;
//+ (InstructionSetEnum *)aload_2;
//+ (InstructionSetEnum *)aload_3;
//+ (InstructionSetEnum *)anewarray;
//+ (InstructionSetEnum *)areturn;
//+ (InstructionSetEnum *)arraylength;
//+ (InstructionSetEnum *)astore;
//+ (InstructionSetEnum *)astore_0;
//+ (InstructionSetEnum *)astore_1;
//+ (InstructionSetEnum *)astore_2;
//+ (InstructionSetEnum *)astore_3;
//+ (InstructionSetEnum *)athrow;
//+ (InstructionSetEnum *)baload;
//+ (InstructionSetEnum *)bastore;
//+ (InstructionSetEnum *)bipush;
//+ (InstructionSetEnum *)caload;
//+ (InstructionSetEnum *)castore;
//+ (InstructionSetEnum *)checkcast;
//+ (InstructionSetEnum *)dadd;
//+ (InstructionSetEnum *)daload;
//+ (InstructionSetEnum *)dastore;
//+ (InstructionSetEnum *)dcmpg;
//+ (InstructionSetEnum *)dcmpl;
//+ (InstructionSetEnum *)dconst_0;
//+ (InstructionSetEnum *)dconst_1;
//+ (InstructionSetEnum *)ddiv;
//+ (InstructionSetEnum *)dload;
//+ (InstructionSetEnum *)dload_0;
//+ (InstructionSetEnum *)dload_1;
//+ (InstructionSetEnum *)dload_2;
//+ (InstructionSetEnum *)dload_3;
//+ (InstructionSetEnum *)dmul;
//+ (InstructionSetEnum *)dneg;
//+ (InstructionSetEnum *)drem;
//+ (InstructionSetEnum *)dreturn;
//+ (InstructionSetEnum *)dstore;
//+ (InstructionSetEnum *)dstore_0;
//+ (InstructionSetEnum *)dstore_1;
//+ (InstructionSetEnum *)dstore_2;
//+ (InstructionSetEnum *)dstore_3;
//+ (InstructionSetEnum *)dsub;
//+ (InstructionSetEnum *)dup;
//+ (InstructionSetEnum *)dup_x1;
//+ (InstructionSetEnum *)dup_x2;
//+ (InstructionSetEnum *)dup2;
//+ (InstructionSetEnum *)dup2_x1;
//+ (InstructionSetEnum *)dup2_x2;
//+ (InstructionSetEnum *)fadd;
//+ (InstructionSetEnum *)faload;
//+ (InstructionSetEnum *)fastore;
//+ (InstructionSetEnum *)fcmpg;
//+ (InstructionSetEnum *)fcmpl;
//+ (InstructionSetEnum *)fconst_0;
//+ (InstructionSetEnum *)fconst_1;
//+ (InstructionSetEnum *)fconst_2;
//+ (InstructionSetEnum *)fdiv;
//+ (InstructionSetEnum *)fload;
//+ (InstructionSetEnum *)fload_0;
//+ (InstructionSetEnum *)fload_1;
//+ (InstructionSetEnum *)fload_2;
//+ (InstructionSetEnum *)fload_3;
//+ (InstructionSetEnum *)fmul;
//+ (InstructionSetEnum *)fneg;
//+ (InstructionSetEnum *)frem;
//+ (InstructionSetEnum *)freturn;
//+ (InstructionSetEnum *)fstore;
//+ (InstructionSetEnum *)fstore_0;
//+ (InstructionSetEnum *)fstore_1;
//+ (InstructionSetEnum *)fstore_2;
//+ (InstructionSetEnum *)fstore_3;
//+ (InstructionSetEnum *)fsub;
//+ (InstructionSetEnum *)getfield;
//+ (InstructionSetEnum *)getstatic;
//+ (InstructionSetEnum *)Goto;
//+ (InstructionSetEnum *)goto_w;
//+ (InstructionSetEnum *)i2l;
//+ (InstructionSetEnum *)i2f;
//+ (InstructionSetEnum *)i2d;
//+ (InstructionSetEnum *)l2i;
//+ (InstructionSetEnum *)l2f;
//+ (InstructionSetEnum *)l2d;
//+ (InstructionSetEnum *)f2i;
//+ (InstructionSetEnum *)f2l;
//+ (InstructionSetEnum *)f2d;
//+ (InstructionSetEnum *)d2i;
//+ (InstructionSetEnum *)d2l;
//+ (InstructionSetEnum *)d2f;
//+ (InstructionSetEnum *)i2b;
//+ (InstructionSetEnum *)i2c;
//+ (InstructionSetEnum *)i2s;
//+ (InstructionSetEnum *)iadd;
//+ (InstructionSetEnum *)iaload;
//+ (InstructionSetEnum *)iand;
//+ (InstructionSetEnum *)iastore;
//+ (InstructionSetEnum *)iconst_m1;
//+ (InstructionSetEnum *)iconst_0;
//+ (InstructionSetEnum *)iconst_1;
//+ (InstructionSetEnum *)iconst_2;
//+ (InstructionSetEnum *)iconst_3;
//+ (InstructionSetEnum *)iconst_4;
//+ (InstructionSetEnum *)iconst_5;
//+ (InstructionSetEnum *)idiv;
//+ (InstructionSetEnum *)if_acmpeq;
//+ (InstructionSetEnum *)if_acmpne;
//+ (InstructionSetEnum *)if_icmpeq;
//+ (InstructionSetEnum *)if_icmpne;
//+ (InstructionSetEnum *)if_icmplt;
//+ (InstructionSetEnum *)if_icmpge;
//+ (InstructionSetEnum *)if_icmpgt;
//+ (InstructionSetEnum *)if_icmple;
//+ (InstructionSetEnum *)ifeq;
//+ (InstructionSetEnum *)ifne;
//+ (InstructionSetEnum *)iflt;
//+ (InstructionSetEnum *)ifge;
//+ (InstructionSetEnum *)ifgt;
//+ (InstructionSetEnum *)ifle;
//+ (InstructionSetEnum *)ifnonnull;
//+ (InstructionSetEnum *)ifnull;
//+ (InstructionSetEnum *)iinc;
//+ (InstructionSetEnum *)iload;
//+ (InstructionSetEnum *)iload_0;
//+ (InstructionSetEnum *)iload_1;
//+ (InstructionSetEnum *)iload_2;
//+ (InstructionSetEnum *)iload_3;
//+ (InstructionSetEnum *)imul;
//+ (InstructionSetEnum *)ineg;
//+ (InstructionSetEnum *)instanceoff;
//+ (InstructionSetEnum *)invokedynamic;
//+ (InstructionSetEnum *)invokeinterface;
//+ (InstructionSetEnum *)invokespecial;
//+ (InstructionSetEnum *)invokestatic;
//+ (InstructionSetEnum *)invokevirtual;
//+ (InstructionSetEnum *)ior;
//+ (InstructionSetEnum *)irem;
//+ (InstructionSetEnum *)ireturn;
//+ (InstructionSetEnum *)ishl;
//+ (InstructionSetEnum *)ishr;
//+ (InstructionSetEnum *)istore;
//+ (InstructionSetEnum *)istore_0;
//+ (InstructionSetEnum *)istore_1;
//+ (InstructionSetEnum *)istore_2;
//+ (InstructionSetEnum *)istore_3;
//+ (InstructionSetEnum *)isub;
//+ (InstructionSetEnum *)iushr;
//+ (InstructionSetEnum *)ixor;
//+ (InstructionSetEnum *)jsr;
//+ (InstructionSetEnum *)jsr_w;
//+ (InstructionSetEnum *)ladd;
//+ (InstructionSetEnum *)laload;
//+ (InstructionSetEnum *)land;
//+ (InstructionSetEnum *)lastore;
//+ (InstructionSetEnum *)lcmp;
//+ (InstructionSetEnum *)lconst_0;
//+ (InstructionSetEnum *)lconst_1;
//+ (InstructionSetEnum *)ldc;
//+ (InstructionSetEnum *)ldc_w;
//+ (InstructionSetEnum *)ldc2_w;
//+ (InstructionSetEnum *)ldiv;
//+ (InstructionSetEnum *)lload;
//+ (InstructionSetEnum *)lload_0;
//+ (InstructionSetEnum *)lload_1;
//+ (InstructionSetEnum *)lload_2;
//+ (InstructionSetEnum *)lload_3;
//+ (InstructionSetEnum *)lmul;
//+ (InstructionSetEnum *)lneg;
//+ (InstructionSetEnum *)lookupswitch;
//+ (InstructionSetEnum *)lor;
//+ (InstructionSetEnum *)lrem;
//+ (InstructionSetEnum *)lreturn;
//+ (InstructionSetEnum *)lshl;
//+ (InstructionSetEnum *)lshr;
//+ (InstructionSetEnum *)lstore;
//+ (InstructionSetEnum *)lstore_0;
//+ (InstructionSetEnum *)lstore_1;
//+ (InstructionSetEnum *)lstore_2;
//+ (InstructionSetEnum *)lstore_3;
//+ (InstructionSetEnum *)lsub;
//+ (InstructionSetEnum *)lushr;
//+ (InstructionSetEnum *)lxor;
//+ (InstructionSetEnum *)monitorenter;
//+ (InstructionSetEnum *)monitorexit;
//+ (InstructionSetEnum *)multianewarray;
//+ (InstructionSetEnum *)New;
//+ (InstructionSetEnum *)newarray;
//+ (InstructionSetEnum *)nop;
//+ (InstructionSetEnum *)pop;
//+ (InstructionSetEnum *)pop2;
//+ (InstructionSetEnum *)putfield;
//+ (InstructionSetEnum *)putstatic;
//+ (InstructionSetEnum *)ret;
//+ (InstructionSetEnum *)Return;
//+ (InstructionSetEnum *)saload;
//+ (InstructionSetEnum *)sastore;
//+ (InstructionSetEnum *)sipush;
//+ (InstructionSetEnum *)swap;
//+ (InstructionSetEnum *)tableswitch;
//+ (InstructionSetEnum *)wide;
//+ (InstructionSetEnum *)breakpoint;
//+ (InstructionSetEnum *)impdep1;
//+ (InstructionSetEnum *)impdep2;
//+ (InstructionSetEnum *)label;
//+ (NSMutableArray *)values;
//+ (InstructionSetEnum *)valueOfWithNSString:(NSString *)name;
//- (id)copyWithZone:(NSZone *)zone;
//+ (InstructionSetEnum *)convertWithByte:(char)b;
//- (id)initWithNSString:(NSString *)__name withInt:(int)__ordinal;
//@end

